import { Language } from './language';
import { languages } from './languages';
import { languageFactory } from './languages';
import mock, { fs } from 'mock-fs';
import AdmZip from 'adm-zip';
import { EOL } from 'os';

export interface Directory {
  [index: string]: any;
}

/**
 * builds a directory object for mock-fs. Used to generate the zip file to
 * be returned by the revert function.
 * @param paths any path string starting from root and split into array
 * @param dirs Directory object with root directory as only key
 * @returns the last subdir as Directory object from the paths parameter
 */
export const constructDirectoryObject = (
  paths: string[],
  dirs: Directory,
  root: Directory
): Directory => {
  const nextDir = paths.pop();

  if (nextDir === undefined) {
    return root;
  }

  if (nextDir === '') {
    return constructDirectoryObject(paths, dirs['/'], root); //for valid subdirs, this is return of root...
  }
  if (paths.length === 0) {
    if (nextDir in dirs) {
      return dirs[nextDir]; //case - sub dir file
    }
    dirs[nextDir] = {};
    return dirs[nextDir]; //case - sub dir file, sub dir didnt exist
  } else {
    if (nextDir in dirs) {
      return constructDirectoryObject(paths, dirs[nextDir], root); //subdir
    }
    dirs[nextDir] = {};
    return constructDirectoryObject(paths, dirs[nextDir], root); //subdir didnt exist
  }
};

/**
 * Reverts a file (presumably generated by compose) into its corresponding directory form
 * Scans for comment lines beginning with the language defined guards.
 * Lines matching: <language.comment><language.beginGuard>filename mark the beginning of the given filename
 * while lines matching <language.comment><language.engGuard>filename mark the end of a file
 * These wrappers are assumed to be no greater than one file deep at any time.
 * Files should be perfectly replicated between the wrappers, with special cases or modifications
 * capable of being handled on a line by line basis defined by language.processline() in language.ts
 * Code outside these wrappers are ignored.
 * The filenames need to be full directory paths, including the desired zip name.
 * The file is assumed to begin at the comment line
 * specifying the beginning guard and end at the comment line specifying the
 * @param file composed file as a buffer
 * @param langauge the langauge of the composed file
 * @returns a buffer representing the zip of the file tree
 */
export const revert = (file: Buffer, language: string): Buffer => {
  const languageInstance: Language = languages[language];

  const comment = languageInstance.getCommentLiteral();
  const BEGIN = comment + languageInstance.getBeginGuard();
  const END = comment + languageInstance.getEndGuard();

  const lines: string[] = file
    .toString()
    .split('\r')
    .join('')
    .split('\n');

  const stack: number[] = new Array<number>();

  const mockdir: Directory = {};
  mockdir['/'] = {};

  lines
    .filter((line: string, index: number) => {
      if (line.match(BEGIN)) {
        stack.push(index + 1);
        return true;
      }
      if (line.match(END)) {
        stack.push(index);
        return false;
      }
      return false;
    })
    .map((line: string) => {
      return line.split(BEGIN)[1].trim();
    })
    .reverse()
    .map((dir: string) => {
      const end: number = stack.pop() as number;
      const begin: number = stack.pop() as number;
      dir = '/' + dir;

      const dirObj = constructDirectoryObject(
        dir
          .split('/')
          .slice(0, -1)
          .reverse(),
        mockdir,
        mockdir['/']
      );

      dirObj[dir.split('/').slice(-1)[0]] = lines
        .slice(begin, end)
        .map(languageInstance.processLine)
        .join(EOL);
    });

  const dirs = {};
  Object.assign(dirs, mockdir);
  mock(dirs, { createCwd: false, createTmp: false });

  const fzip = new AdmZip();
  fzip.addLocalFolder('/');
  const zipBuffer: Buffer = fzip.toBuffer();

  mock.restore();
  return zipBuffer;
};
